#!/usr/bin/env python3
# -*- coding: utf-8 -*-
__author__ = 'petro-ew'


"""
22. = не смогла
Решить задачу 19,
 используя множества вместо списков для возвращения результата и хранения промежуточных данных.
 19 =  Написать функцию, берущую в качестве параметра список уникальных строк,
 и возвращающую список всех пар строк (в виде кортежа), таких,
  что первая строка пары представляет собой вторую строку, записанную задом наперед.
Пример: ['ab', 'bac', 'sss', 'cab', 'ex', 'ba'] -> [('ab', 'ba'), ('bac', 'cab')]
"""
l1 = ['ab', 'bac', 'sss', 'cab', 'ex', 'ba']

def funck(l1):
    l = set()
    for i in range(len(l1)):
        for j in range(i+1, len(l1)):
            if l1[i] == l1[j][::-1]:
                l.add((l1[i], l1[j]))
    return l
print(funck(l1))#!/usr/bin/env python3
# -*- coding: utf-8 -*-
__author__ = 'petro-ew'


"""
22. = не смогла
Решить задачу 19,
 используя множества вместо списков для возвращения результата и хранения промежуточных данных.
 19 =  Написать функцию, берущую в качестве параметра список уникальных строк,
 и возвращающую список всех пар строк (в виде кортежа), таких,
  что первая строка пары представляет собой вторую строку, записанную задом наперед.
Пример: ['ab', 'bac', 'sss', 'cab', 'ex', 'ba'] -> [('ab', 'ba'), ('bac', 'cab')]
"""
l1 = ['ab', 'bac', 'sss', 'cab', 'ex', 'ba']

def funck(l1):
    l = set()
    for i in range(len(l1)):
        for j in range(i+1, len(l1)):
            if l1[i] == l1[j][::-1]:
                l.add((l1[i], l1[j]))
    return l
print(funck(l1))